\input{$UNI_DIR/msc/tex/HWSetup}
\input{$UNI_DIR/msc/tex/EngBindings}

%
% Homework Details
%   - Title
%   - Subtitle
%   - Due date
%   - Due time
%   - Course
%   - Section/Time
%   - Instructor
%   - Author
%

\hwkTitle{Final Project}
\hwkSubTitle{Extended Kalman Filter}
\hwkDueDate{2025-12-16}
\hwkDueTime{12:30:00}
\hwkClass{ENAE 441 - 0101}
\hwkClassTime{09:30:00}
\hwkInstructor{Dr. Martin}
\hwkAuthor{Vai Srivastava}
\hwkCompletionDate{\today}

\begin{document}

\maketitle

\pagebreak

\section*{Overview} \label{hwk:overview}

You are working at NASA GSFC on the navigation team for an Earth orbiting science satellite launched into orbit on a Falcon-9. SpaceX designed its launch to deliver the payload into low Earth orbit with reference coordinates of

\[
	\bm{X}_{\text{\oe}}=\left[\begin{array}{c}
			a \\
			e \\
			i \\
			\omega \\
			\Omega \\
			\theta
			\end{array}\right]=\left[\begin{array}{cc}
			\qty{7e3}{\km} \\
			0.2 \\
			\ang{45} \\
			\ang{0} \\
			\ang{270} \\
			\ang{78.75}
	\end{array}\right]
\]

however it's the navigation's team responsibility to verify this orbit and/or determine any errors in its delivery. To accomplish this, the navigation team has access to range and range-rate measurements from the spacecraft provided by the Deep Space Network (DSN). The latitude and longitude \( \left( \phi, \lambda \right) \) of the three DSN ground stations are provided below:
\begin{itemize}
	\item DSN \# 0: Goldstone, USA: \( \left( \ang{35.297}, \ang{-116.914} \right) \)
	\item DSN \# 1: Madrid, Spain: \( \left( \ang{40.4311}, \ang{-4.248} \right) \)
	\item DSN \# 2: Canberra, Australia: \( \left( \ang{-35.4023}, \ang{148.9813} \right) \)
\end{itemize}

These ground stations are positioned on a spherical Earth of radius 6378.137 km , with a rotation rate of \( \omega_{\mathcal{E}/\mathcal{N}} = \qty{7.292115e-5}{\rad\per\s} \) and a Local Sidereal Time of \( \gamma_{0} = \ang{0} \).

\mintinline{python}{Project-Measurements-Easy.npy} contains the range \( \rho \) and range-rate \( \dot{\rho} \) measurements alongside additional information. Specifically, each row in the datafile is formatted as:
\[
	\bvect{t, i, \rho, \dot{\rho}}
\]

where \( t \) corresponds with the time the measurement was received and \( i \) corresponds to the ground station index (as labeled above).

As best as you are aware, the spacecraft's motion is governed by the following differential equation:

\[
	\ddot{\bm{r}}=-\frac{\bm{\mu}}{r^3} \cdot \bm{r}
\]

where \( \bm{r} \) is the position of the spacecraft in the inertial frame. Similarly, the measurements provided can be computed using the following equations:

\begin{align*}
	\bm{\rho} &= \bm{r} - \bm{R}_{\text{site}, i} \\
	\rho &= \left\| \bm{r} -  \bm{R}_{\text{site}, i} \right\| \\
	\dot{\rho} &= \frac{\bm{\rho} \left( \bm{\dot{r}} - \bm{\dot{R}}_{\text{site}, i} \right)}{\rho} \\
	\bm{\dot{R}}_{\text{site}, i} &= \bm{\omega}_{\mathcal{E} / \mathcal{N}} \times \bm{R}_{\text{site}, i}
\end{align*}

where \( \bm{R}_{\text{site}, i} \) is the location of the DSN station also in the inertial frame. Note that the measurements provided by the DSN have some intrinsic noise which can be modeled as Gaussian white noise. Explicitly, the noise in the range is characterized by a variance of \qty{1}{\m\squared}, and by \qty{1}{\cm\squared\per\s\squared} variance in the range-rate.

Using your knowledge of the spacecraft's dynamics and the measurements provided by the DSN, generate a report which culminates in an estimate of the spacecraft's state over time. To help facilitate your progress, please generate your report in the following order, answering the following intermediate questions:

\newpage

\begin{hwkProblem}{1}{Problem Setup} \label{hwk:p01}

	\begin{enumerate}[label=\alph*.]
		\item \label{hwk:p01a} Express the non-linear system in continuous time state-space form, clearly defining the vectors \( \fn{\bm{f}}[\fn{X}[t]] \) and \( \fn{\bm{h}}[\fn{X}[t]] \)
		\item \label{hwk:p01b} Define the linearized dynamics and measurement matrices \( \fn{A}[t] \) and \( \fn{C}[t] \).
		\item \label{hwk:p01c} Show how these matrices are converted to their discrete time forms \( F_{k} \) and \( H_{k} \). Recall \( F_{k} \) is the state transition matrix \( \fn{\bm{\Phi}}[t_{j}, t_{i}] \) which requires integration.
		\item \label{hwk:p01d} Define your noise matrices \( Q_{k} \) and \( R_{k} \), and discuss their relationship to the aforementioned system of equations.
		\item \label{hwk:p01e} Plot the measurements as a function of time.
	\end{enumerate}

	\hwkSol{} \label{hwk:s01}

	\hwkPart{} \label{hwk:s01a}

	First, we use the inertial Cartesian state:
	\[
		\fn{X}[t] \equiv \bvect{\fn{r}[t] \\ \fn{v}[t]} = \bvect{x & y & z & \dot{x} & \dot{y} & \dot{z}}^{T} \in \mathbb{R}^{6}, \quad r, v \in \mathbb{R}^{3}
	\]
	And the two-body point mass model:
	\[
		\dot{r} = v, \quad \dot{v} = -\mu \frac{r}{\left\| r \right\|^{3}}
	\]
	Thus,
	\[
		\fn{f}[X, t] = \bvect{v \\ -\mu \frac{r}{\left\| r \right\|^{3}}}
	\]

	Now, each station's ECEF position is:
	\[
		R_{\text{ECEF}, i} = R_{E} \bvect{ \cos{\phi_{i}} \cos{\lambda_{i}} \\ \cos{\phi_{i}} \sin{\lambda_{i}} \\ \sin{\phi_{i}} }
	\]
	As Earth rotates about inertial \( + \hat{z} \) with \( \omega_{E} = \omega_{\mathcal{E}/\mathcal{N}} \), siderial angle is:
	\[
		\fn{\gamma}[t] = \gamma_{0} + \omega_{E} t
	\]
	Rotating to get the Site positions:
	\[
		R_{\text{site}, i} = \fn{R_{3}}[\fn{\gamma}[t]] R_{\text{ECEF}, i}, \quad \fn{\dot{R}_{\text{site}, i}}[t] = \omega \times \fn{R_{\text{site}, i}}[t], \quad \omega = \bvect{0 \\ 0 \\ \omega_{E}}
	\]

	Now, each station's LOS vector is:
	\[
		\fn{\rho_{i}}[t] = \fn{r}[t] - \fn{R_{\text{site}, i}}[t], \quad \fn{\rho}[t] = \left\|\fn{\rho_{i}}[t]\right\|, \quad \fn{\hat{\rho}}[t] = \frac{\fn{\rho_{i}}[t]}{\fn{\rho}[t]}
	\]
	Range-rate:
	\[
		\fn{\dot{\rho}}[t] = \frac{\fn{\rho_{i}^{T}}[v - \dot{R}_{\text{site}, i}]}{\rho} = \fn{\hat{\rho}^{T}}[v - \dot{R}_{\text{site}, i}]
	\]

	Measurements including noise:
	\[
		\fn{y}[t] = \fn{h}[X, t, i] + \fn{v}[t], \quad \fn{v}[t] \sim \fn{\mathcal{N}}[0, R]
	\]

	\hwkPart{} \label{hwk:s01b}

	With \( \delta X \) as a small perturbation about a refernece trajectory \( \fn{\bar{X}}[t] \),
	\[
		\fn{\delta \dot{X}}[t] = \fn{A}[t] \fn{\delta X}[t], \quad \fn{\delta y}[t] = \fn{C}[t] \fn{\delta X}[t] + \fn{v}[t]
	\]
	\( \fn{A}[t] \) and \( \fn{C}[t] \) are Jacobians:
	\[
		\fn{A}[t] = \left. \pdrv{f}{X} \right|_{\fn{\bar{X}}[t]}, \quad \fn{C}[t] = \left. \pdrv{h}{X} \right|_{\fn{\bar{X}}[t], t, i}
	\]

	Dynamics Jacobian \( A(t) \):

	With \(r=\bar{r}(t), v=\bar{v}(t), r=\|r\|\),
	\[
		A(t) = \bvect{
			\pdrv{\dot{r}}{r} & \pdrv{\dot{r}}{v} \\
			\pdrv{\dot{v}}{r} & \pdrv{\dot{v}}{v}
		} = \bvect{
			0_{3 \times 3} & I_{3 \times 3} \\
			-\mu\left(\frac{1}{r^3} I_{3 \times 3}-\frac{3}{r^5} r r^T\right) & 0_{3 \times 3}
		}
	\]

	Measurement Jacobian \( C(t) \):

	For a measurement taken at time \( t \) from station \( i \),
	\[
		\rho = r-R_{\text{site}, i}(t), \quad \rho = \|\rho\|, \quad u = \hat{\rho} = \rho / \rho, \quad v_{\text{rel}} = v-\dot{R}_{\text{site}, i}(t)
	\]
	Range row:
	\[
		\pdrv{\rho}{r} = u^T, \quad \pdrv{\rho}{v} = 0_{1 \times 3}
	\]
	Range-rate row:
	\[
		\dot{\rho}=u^T v_{\text{rel}}
	\]
	Using \( \pdrv{u}{r}=\frac{1}{\rho}\left(I-u u^T\right) \) (since \( u=\rho /\|\rho\| \) and \( \rho \) depends linearly on \( r \)),
	\[
		\pdrv{\dot{\rho}}{v} = u^T, \quad \pdrv{\dot{\rho}}{r} = v_{\text{rel}}^T \pdrv{u}{r} = \frac{1}{\rho} v_{\text{rel}}^T\left(I-u u^T\right)
	\]
	Thus,
	\[
		C(t) = \bvect{
			u^T & 0_{1 \times 3} \\
			\frac{1}{\rho} v_{\text{rel}}^T\left(I-u u^T\right) & u^T
		}
	\]

	\hwkPart{} \label{hwk:s01c}

	Measurements occur at times \( t_k \) (not necessarily uniform), meaning the EKF-style discrete model is:
	\[
		X_{k+1} = \varphi\left(X_k, t_k, t_{k+1}\right) + w_k, \quad y_k = h\left(X_k, t_k, i_k\right) + v_k
	\]
	The discrete linearized mapping for perturbations is:
	\[
		\delta X_{k+1}=F_k \delta X_k, \quad F_k \equiv \Phi\left(t_{k+1}, t_k\right)
	\]
	\(\boldsymbol{\Phi}\) is obtained by integrating the variational equation alongside the state:
	\[
		\dot{\Phi}\left(t, t_k\right)=A(t) \Phi\left(t, t_k\right), \quad \Phi\left(t_k, t_k\right)=I_{6 \times 6},
	\]
	and then setting:
	\[
		F_k=\Phi\left(t_{k+1}, t_k\right)
	\]
	At measurement time \(t_k\) and station index \(i_k\),
	\[
		H_{k} \equiv C(t_{k}) = \left. \pdrv{h}{X} \right|_{\bar{X}(t_{k}), t_{k}, i_{k}}
	\]

	\hwkPart{} \label{hwk:s01d}

	Measurement noise is simply:
	\[
		R_{k} = \bvect{\sigma_{\rho}^{2} & 0 \\ 0 \sigma_{\dot{\rho}}^{2}}
	\]
	Process noise is used to account for unmodeled accelerations. Here we choose additive white acceleration noise as our process noise model:
	\[
		\dot{r} = v, \quad \dot{v} = -\mu \frac{r}{\|r\|^3} + w_a(t), \quad w_a(t) \sim \mathcal{N}\left(0, Q_c\right),
	\]
	with \( Q_c = q_a I_{3 \times 3} \), and simplifying to:
	\[
		\dot{X} = f(X, t) + G w_a(t), \quad G = \bvect{
			0_{3 \times 3} \\
			I_{3 \times 3}
		}
	\]
	Then the discrete process noise over \( \left[t_k, t_{k+1}\right] \) is
	\[
		Q_k=\int_{t_k}^{t_{k+1}} \Phi\left(t_{k+1}, \tau\right) G Q_c G^T \Phi\left(t_{k+1}, \tau\right)^T d \tau
	\]

	\hwkPart{} \label{hwk:s01e}

	\begin{figure}[H] \label{fig:s01e}
		\begin{center}
			\includegraphics[width=0.85\textwidth]{./outputs/figures/s01e.png}
		\end{center}
		\caption{DSN Range [\unit{\km}] vs. Time [\unit{\s}]}
	\end{figure}

\end{hwkProblem}

\begin{hwkProblem}{2}{Plan Filter Implementation} \label{hwk:p02}

	Provide pseudocode from which you will base your extended Kalman filter implementation. Highlight the major steps in your algorithm and any noteworthy modifications or subtle details required for this problem that you want the grades to be aware of. Be comprehensive, as this is what the grading team will primarily reference if the results/plots don't quite look right.

	\hwkSol{} \label{hwk:s02}

	\begin{minted}{python}
		Inputs:
			data.t[0..N-1], data.i[0..N-1], data.rho[0..N-1], data.drho[0..N-1]
			station lat/lon: (phi[i], lam[i]), i=0..2
			constants: mu, RE, omegaE, gamma0
			noise: R = diag(sig_rho^2, sig_drho^2)   (in FILTER UNITS)
			       Q-model params: q_a (white accel PSD) OR set Qk = 0
			initial: X_plus (6x1), P_plus (6x6)

		Precompute:
			for each station i:
				R_ecef[i] = RE * [cos(phi_i)cos(lam_i), cos(phi_i)sin(lam_i), sin(phi_i)]^T

		Helpers:
			site_eci(i, t):
				gamma = gamma0 + omegaE*t
				R_site = R3(gamma) * R_ecef[i]
				Rdot_site = omega x R_site # (omega = [0,0,omegaE]^T)
				return (R_site, Rdot_site)

			dynamics(X):
				r = X[0:3], v = X[3:6]
				rnorm = ||r||
				rdot = v
				vdot = -mu * r / rnorm^3
				return [rdot; vdot]

			A_matrix(X):
				r = X[0:3]; rnorm = ||r||
				I3 = identity(3)
				dadr = -mu*( (1/rnorm^3)*I3 - (3/rnorm^5)*(r*r^T) )
				return [[0, I3],
				        [dadr, 0]]

			propagate_state_and_stm(X0, t0, t1):
				Integrate coupled ODEs from t0 -> t1:
				Xdot  = dynamics(X)
				Phidot = A_matrix(X) * Phi
				with initial Phi(t0)=I6
				return (X_minus, Phi)   where Phi = Φ(t1,t0)

			meas_and_jacobian(X, i, t):
				(R_site, Rdot_site) = site_eci(i, t)
				r = X[0:3]; v = X[3:6]
				rho_vec = r - R_site
				rho = ||rho_vec||
				u = rho_vec / rho
				v_rel = v - Rdot_site
				drho = u^T * v_rel

				yhat = [rho; drho]

				# Jacobian H = ∂h/∂X (2x6)
				H_rho_r = u^T
				H_rho_v = [0 0 0]

				H_drho_v = u^T
				H_drho_r = (1/rho) * (v_rel^T * (I3 - u*u^T))

				H = [[H_rho_r,  H_rho_v],
				     [H_drho_r, H_drho_v]]
				return (yhat, H)

			process_noise_discrete(dt, q_a):
				if q_a == 0:
					return 0_(6x6)
				else:
					I3 = identity(3)
					Q = q_a * [[(dt^3/3)*I3, (dt^2/2)*I3],
					           [(dt^2/2)*I3, (dt)*I3]]
					return Q

		Main EKF:
			t_prev = data.t[0]

			for k in 0..N-1:
				t_k = data.t[k]
				i_k = data.i[k]
				y_k = [data.rho[k], data.drho[k]]^T

			# Predict / propagate to t_k
			dt = t_k - t_prev
			if dt > 0:
				(X_minus, Phi) = propagate_state_and_stm(X_plus, t_prev, t_k)
				Qk = process_noise_discrete(dt, q_a)
				P_minus = Phi * P_plus * Phi^T + Qk
			else:
				X_minus = X_plus
				P_minus = P_plus
				Phi = I6

			# Measurement prediction at (t_k, i_k)
			(yhat_k, Hk) = meas_and_jacobian(X_minus, i_k, t_k)
			nu = y_k - yhat_k # innovation (2x1)

			# Gain computation
			S = Hk * P_minus * Hk^T + R # (2x2)
			K = P_minus * Hk^T * inv(S) # (6x2)

			# Update (state + Joseph covariance)
			X_plus = X_minus + K * nu
			P_plus = (I6 - K*Hk)*P_minus*(I6 - K*Hk)^T + K*R*K^T

			# Diagnostics
			log residual nu, NIS = nu^T * inv(S) * nu, etc.
			t_prev = t_k

		Outputs:
			filtered state estimates X_plus and X_minus over time
			residual history, NIS history, covariance history
	\end{minted}

	\begin{figure}[H] \label{fig:s02}
		\begin{center}
			\includegraphics[width=0.95\textwidth]{./outputs/figures/s02.png}
		\end{center}
		\caption{(Pseudo) Code Flowchart}
	\end{figure}

\end{hwkProblem}

\begin{hwkProblem}{3}{Pure Prediction} \label{hwk:p03}

	\begin{enumerate}[label=\alph*.]
		\item \label{hwk:p03a} Specify your choice of \( \bm{x}_{0} \), \( P_{0} \), \( Q_{0} \), and \( R_{0} \). Explain your reasoning. (For \( \bm{x}_{0} \), express in cartesian coordinates.)
		\item \label{hwk:p03b} Implement just the prediction step of the extended Kalman Filter (i.e. do not perform measurement updates).
		\item \label{hwk:p03c} Plot the covariance of the state estimate as a function of time, centered about a mean of zero --- i.e. \( \pm 3 \sigma \) bounds taken from \( \fn{P_{\bm{\hat{x}}, k}^{-}}[t] \). Choose appropriate y-limits for your plot to maximize readability. Explain what you see and if it makes sense.
	\end{enumerate}

	\hwkSol{} \label{hwk:s03}

	\hwkPart{} \label{hwk:s03a}

	\( \bm{x}_{0} \) is the nominal spacecraft orbit:
	\[
		\bm{X}_0^{+} \equiv \bvect{r_{0} \\ v_{0}}
	\]

	\( P_{0} \) is chosen to be a diagonal covariance matrix, with the first 3 terms being the range noise uncertainty scaled by the tuning ratio:
	\[
		\sigma_{r}^{2} = \left(\frac{\sigma_{\rho}}{\sigma_{a}}\right)^{2} = \left(\frac{\num{1e-6}}{\num{1e-6}}\left[\unit{\km}\right]\right)^{2}
	\]
	and the final 3 terms being the range-rate noise uncertainty scaled by the tuning ratio:
	\[
		\sigma_{v}^{2} = \left(\frac{\sigma_{\dot{\rho}}}{\sigma_{a}}\right)^{2} = \left(\frac{\num{1e-10}}{\num{1e-6}}\left[\unit{\km\per\s}\right]\right)^{2}
	\]

	\( Q_{0} \) is chosen to be the first-order Wiener discretized continuous white noise acceleration model:
	\[
		Q_k \approx q_a\left[\begin{array}{cc}
				\frac{\Delta t^3}{3} I_3 & \frac{\Delta t^2}{2} I_3 \\
				\frac{\Delta t^2}{2} I_3 & \Delta t I_3
		\end{array}\right]
	\]

	\( R_{0} \) is chosen to be a diagonal covariance matrix, with the first 3 terms being the range noise uncertainty:
	\[
		\sigma_{\rho}^{2} = \left(\num{1e-3}\left[\unit{\km}\right]\right)^{2}
	\]
	and the final 3 terms being the range-rate noise uncertainty
	\[
		\sigma_{\dot{\rho}}^{2} = \left(\num{1e-10}\left[\unit{\km\per\s}\right]\right)^{2}
	\]

	\inputminted{python}{./outputs/text/s03a.txt}

	\hwkPart{} \label{hwk:s03b}

	Implementation can be viewed in the \hyperref[code:final]{Python files} embedded at the end of the report.

	\hwkPart{} \label{hwk:s03c}

	\begin{figure}[H] \label{fig:s03c}
		\begin{center}
			\includegraphics[width=0.85\textwidth]{./outputs/figures/s03c.png}
		\end{center}
		\caption{\( \pm 3 \sigma \) Bounds on Pre- Measurement Covariance \( P_{\bm{\hat{x}}, k}^{-} \) vs. Time \( t \)}
	\end{figure}

	The plot exhibits sawtooth behavior consistent with a white acceleration process noise model (like the Wiener acceleration we chose). This makes sense, as, without a measurement, the uncertainty can only accumulate. As well, the irregular nature of the plot (with regard to the spacing of each ``wedge") is consistent with varying measurement time-gaps.

\end{hwkProblem}

\begin{hwkProblem}{4}{Measurement Updates} \label{hwk:p04}

	\begin{enumerate}[label=\alph*.]
		\item \label{hwk:p04a} Implement the measurement update step of the extended Kalman Filter.
		\item \label{hwk:p04b} Plot the pre- and post-measurement update \( \pm 3 \sigma \) bounds on the same plot. Explain any differences.
		\item \label{hwk:p04c} Plot the difference between the pre- and post-measurement update state estimates, \( \fn{\bm{\mu}_{\bm{\hat{x}}, k}^{+}}[t_{k}] - \fn{\bm{\mu}_{\bm{\hat{x}}, k}^{-}}[t_{k}] \), inside of the pre-measurement covariance \( \pm 3 \sigma \) bounds \( \fn{P_{\bm{\hat{x}}, k}^{+}}[t_{k}] \).
	\end{enumerate}

	\hwkSol{} \label{hwk:s04}

	\hwkPart{} \label{hwk:s04a}

	Implementation can be viewed in the \hyperref[code:final]{Python files} embedded at the end of the report.

	\hwkPart{} \label{hwk:s04b}

	\begin{figure}[H] \label{fig:s04b}
		\begin{center}
			\includegraphics[width=0.85\textwidth]{./outputs/figures/s04b.png}
		\end{center}
		\caption{\( \pm 3 \sigma \) Bounds on Pre- and Post- Measurement Covariance}
	\end{figure}

	The post-update bounds are substantially tighter than the pre-update bounds at the same time, because each range/range-rate measurement injects information and reduces uncertainty (via the Kalman gain and Joseph update). The pre-update bounds grow between measurements (propagation), while the post-update bounds exhibit repeated "pull-downs" (corrections) whenever a measurement is processed. Overall, this behavior is consistent with the propagation \& update cycle of an EKF.

	\pagebreak

	\hwkPart{} \label{hwk:s04c}

	\begin{figure}[H] \label{fig:s04c}
		\begin{center}
			\includegraphics[width=0.85\textwidth]{./outputs/figures/s04c.png}
		\end{center}
		\caption{Difference Between Pre- and Post-Measurement Update State Estimates}
	\end{figure}

\end{hwkProblem}

\begin{hwkProblem}{5}{Filter Solutions} \label{hwk:p05}

	\begin{enumerate}[label=\alph*.]
		\item \label{hwk:p05a} With your EKF implemented, run the simulation through to completion and compute the post-fit measurement residuals as a function of time via:
			\[
				\fn{\delta \bm{Y}}[t_{k}] = \fn{\bm{Y}}[t_{k}] - \fn{h}[\fn{\bm{\mu}_{\bm{\hat{x}}, k}^{+}}[t_{k}]]
			\]
		\item \label{hwk:p05b} Do your measurement residuals give you confidence that you estimated the state correctly? Why or why not?
		\item \label{hwk:p05c} Plot the estimated state \( \fn{\bm{\mu}_{\bm{\hat{x}}, k}^{+}}[t_{k}] \) and its associated \( \pm 3 \sigma \) bounds taken from \( \fn{P_{\bm{\hat{x}}, k}^{+}}[t] \) as a function of time.
		\item \label{hwk:p05d} Report your best state estimate at the final time-step and its associated uncertainty.
	\end{enumerate}

	\hwkSol{} \label{hwk:s05}

	\hwkPart{} \label{hwk:s05a}

	\begin{figure}[H] \label{fig:s05a}
		\begin{center}
			\includegraphics[width=0.85\textwidth]{./outputs/figures/s05a.png}
		\end{center}
		\caption{Post-Fit Measurement Residuals \( \delta \bm{Y} \) vs. Time \( t \)}
	\end{figure}

	\pagebreak

	\hwkPart{} \label{hwk:s05b}

	\inputminted{python}{./outputs/text/s05b.txt}

	Yes, the residuals strongly support that the estimated state is correct and that the filter is well-tuned/consistent. There are three key pieces of evidence to support this claim:
	\begin{itemize}
		\item The post-fit residuals plotted in \hyperref[fig:s05a]{Part A} appear zero-mean and noise-like, without obvious drifts or station-dependent biases.
		\item Quantitatively, the post-fit RMS residuals are the same order of magnitude (and scale) of the measurement noise:
			\subitem RMS range residual \( \approx 0.970 \unit{\m} \)
			\subitem RMS range-rate residual \( \approx 0.817 \unit{\cm\per\s} \)
		\item The mean pre-fit NIS is \( \approx 1.950 \) for \( df = 2 \), which is close to the expected value \( \left(\approx 2\right) \) for a statistically consistent filter with 2 measurement dimensions.
	\end{itemize}

	\hwkPart{} \label{hwk:s05c}

	\begin{figure}[H] \label{fig:s05c}
		\begin{center}
			\includegraphics[width=0.85\textwidth]{./outputs/figures/s05c.png}
		\end{center}
		\caption{Estimated State \( \bm{\mu}_{\bm{\hat{x}}, k}^{+} \) with \( \pm 3 \sigma \) Bounds vs. Time \( t \)}
	\end{figure}

	\hwkPart{} \label{hwk:s05d}

	\inputminted{python}{./outputs/text/s05d.txt}

\end{hwkProblem}

\begin{hwkProblem}{6}{Debugging Efforts \textit{(Optional)}} \label{hwk:p06}

	Use this section to outline any of your debugging efforts for if things aren't going your way. This is a good place to earn some partial credit. This should be a ``research'' log of what experiments you performed and why. A list of guiding questions if your stuck include:
	\begin{enumerate}
		\item Consider how process noise matrix is used in the filter. What happens if there are large gaps between measurements?
		\item Consider if the values used in your measurement noise matrix are appropriate. Should these values only reflect the uncertainty in the sensor?
		\item If your filter is diverging, does the divergence start at the beginning or mid-way through? What possible reasons exist for either outcome?
		\item If you had to define a single scalar metric to evaluate your filter's quality, what would it be, and can you use this to help you determine optimal tuning values?
		\item Does plotting your best estimate in a different reference frame or element description help?
	\end{enumerate}

	\hwkSol{} \label{hwk:s06}

	\textit{N/A?}

	I am honestly not sure what to put here, as I was fairly confident in my solution throughout the entirety of my time working on this project. Especially once I computed my result for \hyperref[hwk:p05b]{Problem 5, Part B}, any worry that my solution was inadequate was completely gone.

	I attribute the ease of development on this project to three things:
	\begin{enumerate}
		\item Thorough structuring and architecting of my planned solution before implementation.
		\item Strictly typing all variables, objects, and functions throughout my codebase (thank you \href{https://typing.python.org/en/latest/index.html}{Python 3.13}).
		\item Modularization/functional-decomposition of my codebase.
	\end{enumerate}

\end{hwkProblem}

\begin{hwkProblem}{7}{Challenge Orbit \textit{(Bonus)}} \label{hwk:p07}

	Perform a second analysis with the more difficult dataset \mintinline{python}{Project-Measurements-Hard.npy}. Use
	\[
		\bvect{
			a \\
			e \\
			i \\
			\omega \\
			\Omega \\
			\theta
		} = \bvect{
			\qty{7000}{\km} \\
			0.6 \\
			\ang{45} \\
			\ang{180} \\
			\ang{0} \\
			\ang{45}
		}
	\]
	as your initial guess. Your analysis can amount to your debugging process, and points will be awarded based on how thoughtful your experimentation is and the quality of your solution.

	\hwkSol{} \label{hwk:s07}

	Answer

\end{hwkProblem}

\section*{Code} \label{code:final}

See the \href{https://www.github.com/vaisriv/enae441-final/blob/main/src}{full source code} for this project.

\subsection*{\mintinline{bash}{./src/final.py}}
\inputminted{python}{./src/final.py}

\subsection*{\mintinline{bash}{./src/p01.py}}
\inputminted{python}{./src/p01.py}

\subsection*{\mintinline{bash}{./src/p03.py}}
\inputminted{python}{./src/p03.py}

\subsection*{\mintinline{bash}{./src/p04.py}}
\inputminted{python}{./src/p04.py}

\subsection*{\mintinline{bash}{./src/p05.py}}
\inputminted{python}{./src/p05.py}

\subsection*{\mintinline{bash}{./src/helpers/propagators.py}}
\inputminted{python}{./src/helpers/propagators.py}

\subsection*{\mintinline{bash}{./src/helpers/system.py}}
\inputminted{python}{./src/helpers/system.py}

\subsection*{\mintinline{bash}{./src/measurements/measurements.py}}
\inputminted{python}{./src/measurements/measurements.py}

\subsection*{\mintinline{bash}{./src/measurements/numpy_data.py}}
\inputminted{python}{./src/measurements/numpy_data.py}

\end{document}
